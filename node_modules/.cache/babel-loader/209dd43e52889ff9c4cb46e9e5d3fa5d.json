{"ast":null,"code":"/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i,\n      j,\n      k,\n      g,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      isGeometryCollection,\n      isFeatureCollection = layer.type === 'FeatureCollection',\n      isFeature = layer.type === 'Feature',\n      stop = isFeatureCollection ? layer.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n      wrapShrink = excludeWrapCoord && (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') ? 1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\n\nmodule.exports.coordEach = coordEach;\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\n\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function (coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\n\nmodule.exports.coordReduce = coordReduce;\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\n\nfunction propEach(layer, callback) {\n  var i;\n\n  switch (layer.type) {\n    case 'FeatureCollection':\n      features = layer.features;\n\n      for (i = 0; i < layer.features.length; i++) {\n        callback(layer.features[i].properties);\n      }\n\n      break;\n\n    case 'Feature':\n      callback(layer.properties);\n      break;\n  }\n}\n\nmodule.exports.propEach = propEach;\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\n\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function (prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\n\nmodule.exports.propReduce = propReduce;","map":{"version":3,"sources":["/Users/altafquadri/Development/code/Mod5Project/Frontend/lead-us-react/node_modules/turf-meta/index.js"],"names":["coordEach","layer","callback","excludeWrapCoord","i","j","k","g","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","isGeometryCollection","isFeatureCollection","type","isFeature","stop","features","length","geometries","coordinates","l","Error","module","exports","coordReduce","memo","coord","propEach","properties","propReduce","prop"],"mappings":"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","sourcesContent":["/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i, j, k, g, geometry, stopG, coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    isGeometryCollection,\n    isFeatureCollection = layer.type === 'FeatureCollection',\n    isFeature = layer.type === 'Feature',\n    stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n\n    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n\n      geometry = isGeometryCollection ?\n          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n\n      wrapShrink = (excludeWrapCoord &&\n        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n        1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length - wrapShrink; k++)\n            callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length; k++)\n            for (l = 0; l < coords[j][k].length - wrapShrink; l++)\n              callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function(coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\nfunction propEach(layer, callback) {\n  var i;\n  switch (layer.type) {\n      case 'FeatureCollection':\n        features = layer.features;\n        for (i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i].properties);\n        }\n        break;\n      case 'Feature':\n        callback(layer.properties);\n        break;\n  }\n}\nmodule.exports.propEach = propEach;\n\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function(prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\nmodule.exports.propReduce = propReduce;\n"]},"metadata":{},"sourceType":"script"}