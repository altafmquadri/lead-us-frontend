{"ast":null,"code":"import { createStore, applyMiddleware, bindActionCreators } from 'redux';\nimport thunk from 'redux-thunk';\nimport { decode } from '@mapbox/polyline';\nimport utils from './utils';\nimport rootReducer from './reducers';\nconst storeWithMiddleware = applyMiddleware(thunk)(createStore);\nconst store = storeWithMiddleware(rootReducer); // State object management via redux\n\nimport * as actions from './actions';\nimport directionsStyle from './directions_style'; // Controls\n\nimport Inputs from './controls/inputs';\nimport Instructions from './controls/instructions';\n/**\n * The Directions control\n * @class MapboxDirections\n *\n * @param {Object} options\n * @param {Array} [options.styles] Override default layer properties of the [directions source](https://github.com/mapbox/mapbox-gl-directions/blob/master/src/directions_style.js). Documentation for each property are specified in the [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/).\n * @param {String} [options.accessToken=null] Required unless `mapboxgl.accessToken` is set globally\n * @param {String} [options.api=\"https://api.mapbox.com/directions/v5/\"] Override default routing endpoint url\n * @param {Boolean} [options.interactive=true] Enable/Disable mouse or touch interactivity from the plugin\n * @param {String} [options.profile=\"mapbox/driving-traffic\"] Routing profile to use. Options: `mapbox/driving-traffic`, `mapbox/driving`, `mapbox/walking`, `mapbox/cycling`\n * @param {Boolean} [options.alternatives=false] Whether to enable alternatives.\n * @param {Boolean} [options.congestion=false] Whether to enable congestion along the route line.\n * @param {String} [options.unit=\"imperial\"] Measurement system to be used in navigation instructions. Options: `imperial`, `metric`\n * @param {Function} [options.compile=null] Provide a custom function for generating instruction, compatible with osrm-text-instructions.\n * @param {Object} [options.geocoder] Accepts an object containing the query parameters as [documented here](https://www.mapbox.com/api-documentation/#search-for-places).\n * @param {Object} [options.controls]\n * @param {Boolean} [options.controls.inputs=true] Hide or display the inputs control.\n * @param {Boolean} [options.controls.instructions=true] Hide or display the instructions control.\n * @param {Boolean} [options.controls.profileSwitcher=true] Hide or display the default profile switch with options for traffic, driving, walking and cycling.\n * @param {Number} [options.zoom=16] If no bbox exists from the geocoder result, the zoom you set here will be used in the flyTo.\n * @param {String} [options.language=\"en\"] The language of returned turn-by-turn text instructions. See supported languages : https://docs.mapbox.com/api/navigation/#instructions-languages\n * @param {String} [options.placeholderOrigin=\"Choose a starting place\"] If set, this text will appear as the placeholder attribute for the origin input element.\n * @param {String} [options.placeholderDestination=\"Choose destination\"] If set, this text will appear as the placeholder attribute for the destination input element.\n * @param {Boolean} [options.flyTo=true] If false, animating the map to a selected result is disabled.\n * @example\n * var MapboxDirections = require('../src/index');\n * var directions = new MapboxDirections({\n *   accessToken: 'YOUR-MAPBOX-ACCESS-TOKEN',\n *   unit: 'metric',\n *   profile: 'mapbox/cycling'\n * });\n * // add to your mapboxgl map\n * map.addControl(directions);\n *\n * @return {MapboxDirections} `this`\n */\n\nexport default class MapboxDirections {\n  constructor(options) {\n    this.actions = bindActionCreators(actions, store.dispatch);\n    this.actions.setOptions(options || {});\n    this.options = options || {};\n    this.onDragDown = this._onDragDown.bind(this);\n    this.onDragMove = this._onDragMove.bind(this);\n    this.onDragUp = this._onDragUp.bind(this);\n    this.move = this._move.bind(this);\n    this.onClick = this._clickHandler().bind(this);\n  }\n\n  onAdd(map) {\n    this._map = map;\n\n    const _store$getState = store.getState(),\n          controls = _store$getState.controls;\n\n    var el = this.container = document.createElement('div');\n    el.className = 'mapboxgl-ctrl-directions mapboxgl-ctrl'; // Add controls to the page\n\n    const inputEl = document.createElement('div');\n    inputEl.className = 'directions-control directions-control-inputs';\n    new Inputs(inputEl, store, this.actions, this._map);\n    const directionsEl = document.createElement('div');\n    directionsEl.className = 'directions-control directions-control-instructions';\n    new Instructions(directionsEl, store, {\n      hoverMarker: this.actions.hoverMarker,\n      setRouteIndex: this.actions.setRouteIndex\n    }, this._map);\n    if (controls.inputs) el.appendChild(inputEl);\n    if (controls.instructions) el.appendChild(directionsEl);\n    this.subscribedActions();\n    if (this._map.loaded()) this.mapState();else this._map.on('load', () => this.mapState());\n    return el;\n  }\n  /**\n   * Removes the control from the map it has been added to. This is called by `map.removeControl`,\n   * which is the recommended method to remove controls.\n   *\n   * @returns {Control} `this`\n   */\n\n\n  onRemove(map) {\n    this.container.parentNode.removeChild(this.container);\n    this.removeRoutes();\n    map.off('mousedown', this.onDragDown);\n    map.off('mousemove', this.move);\n    map.off('touchstart', this.onDragDown);\n    map.off('touchstart', this.move);\n    map.off('click', this.onClick);\n\n    if (this.storeUnsubscribe) {\n      this.storeUnsubscribe();\n      delete this.storeUnsubscribe;\n    }\n\n    directionsStyle.forEach(layer => {\n      if (map.getLayer(layer.id)) map.removeLayer(layer.id);\n    });\n    if (map.getSource('directions')) map.removeSource('directions');\n    this._map = null;\n    return this;\n  }\n\n  mapState() {\n    const _store$getState2 = store.getState(),\n          profile = _store$getState2.profile,\n          alternatives = _store$getState2.alternatives,\n          congestion = _store$getState2.congestion,\n          styles = _store$getState2.styles,\n          interactive = _store$getState2.interactive,\n          compile = _store$getState2.compile; // Emit any default or option set config\n\n\n    this.actions.eventEmit('profile', {\n      profile\n    });\n    const geojson = {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: []\n      }\n    }; // Add and set data theme layer/style\n\n    this._map.addSource('directions', geojson); // Add direction specific styles to the map\n\n\n    if (styles && styles.length) styles.forEach(style => this._map.addLayer(style));\n    directionsStyle.forEach(style => {\n      // only add the default style layer if a custom layer wasn't provided\n      if (!this._map.getLayer(style.id)) this._map.addLayer(style);\n    });\n\n    if (interactive) {\n      this._map.on('mousedown', this.onDragDown);\n\n      this._map.on('mousemove', this.move);\n\n      this._map.on('click', this.onClick);\n\n      this._map.on('touchstart', this.move);\n\n      this._map.on('touchstart', this.onDragDown);\n    }\n  }\n\n  subscribedActions() {\n    this.storeUnsubscribe = store.subscribe(() => {\n      const _store$getState3 = store.getState(),\n            origin = _store$getState3.origin,\n            destination = _store$getState3.destination,\n            hoverMarker = _store$getState3.hoverMarker,\n            directions = _store$getState3.directions,\n            routeIndex = _store$getState3.routeIndex;\n\n      const geojson = {\n        type: 'FeatureCollection',\n        features: [origin, destination, hoverMarker].filter(d => {\n          return d.geometry;\n        })\n      };\n\n      if (directions.length) {\n        directions.forEach((feature, index) => {\n          const features = [];\n          const decoded = decode(feature.geometry, 5).map(function (c) {\n            return c.reverse();\n          });\n          decoded.forEach(function (c, i) {\n            var previous = features[features.length - 1];\n            var congestion = feature.legs[0].annotation && feature.legs[0].annotation.congestion && feature.legs[0].annotation.congestion[i - 1];\n\n            if (previous && (!congestion || previous.properties.congestion === congestion)) {\n              previous.geometry.coordinates.push(c);\n            } else {\n              var segment = {\n                geometry: {\n                  type: 'LineString',\n                  coordinates: []\n                },\n                properties: {\n                  'route-index': index,\n                  route: index === routeIndex ? 'selected' : 'alternate'\n                }\n              }; // New segment starts with previous segment's last coordinate.\n\n              if (previous) segment.geometry.coordinates.push(previous.geometry.coordinates[previous.geometry.coordinates.length - 1]);\n              segment.geometry.coordinates.push(c);\n\n              if (congestion) {\n                segment.properties.congestion = feature.legs[0].annotation.congestion[i - 1];\n              }\n\n              features.push(segment);\n            }\n          });\n          geojson.features = geojson.features.concat(features);\n\n          if (index === routeIndex) {\n            // Collect any possible waypoints from steps\n            feature.legs[0].steps.forEach(d => {\n              if (d.maneuver.type === 'waypoint') {\n                geojson.features.push({\n                  type: 'Feature',\n                  geometry: d.maneuver.location,\n                  properties: {\n                    id: 'waypoint'\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n\n      if (this._map.style && this._map.getSource('directions')) {\n        this._map.getSource('directions').setData(geojson);\n      }\n    });\n  }\n\n  _clickHandler() {\n    var timer = null;\n    var delay = 250;\n    return function (event) {\n      if (!timer) {\n        var singleClickHandler = this._onSingleClick.bind(this);\n\n        timer = setTimeout(function () {\n          singleClickHandler(event);\n          timer = null;\n        }, delay);\n      } else {\n        clearTimeout(timer);\n        timer = null;\n\n        this._map.zoomIn();\n      }\n    };\n  }\n\n  _onSingleClick(e) {\n    const _store$getState4 = store.getState(),\n          origin = _store$getState4.origin;\n\n    const coords = [e.lngLat.lng, e.lngLat.lat];\n\n    if (!origin.geometry) {\n      this.actions.setOriginFromCoordinates(coords);\n    } else {\n      const features = this._map.queryRenderedFeatures(e.point, {\n        layers: ['directions-origin-point', 'directions-destination-point', 'directions-waypoint-point', 'directions-route-line-alt']\n      });\n\n      if (features.length) {\n        // Remove any waypoints\n        features.forEach(f => {\n          if (f.layer.id === 'directions-waypoint-point') {\n            this.actions.removeWaypoint(f);\n          }\n        });\n\n        if (features[0].properties.route === 'alternate') {\n          const index = features[0].properties['route-index'];\n          this.actions.setRouteIndex(index);\n        }\n      } else {\n        this.actions.setDestinationFromCoordinates(coords);\n\n        this._map.flyTo({\n          center: coords\n        });\n      }\n    }\n  }\n\n  _move(e) {\n    const _store$getState5 = store.getState(),\n          hoverMarker = _store$getState5.hoverMarker;\n\n    const features = this._map.queryRenderedFeatures(e.point, {\n      layers: ['directions-route-line-alt', 'directions-route-line', 'directions-origin-point', 'directions-destination-point', 'directions-hover-point']\n    });\n\n    this._map.getCanvas().style.cursor = features.length ? 'pointer' : '';\n\n    if (features.length) {\n      this.isCursorOverPoint = features[0];\n\n      this._map.dragPan.disable(); // Add a possible waypoint marker when hovering over the active route line\n\n\n      features.forEach(feature => {\n        if (feature.layer.id === 'directions-route-line') {\n          this.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);\n        } else if (hoverMarker.geometry) {\n          this.actions.hoverMarker(null);\n        }\n      });\n    } else if (this.isCursorOverPoint) {\n      this.isCursorOverPoint = false;\n\n      this._map.dragPan.enable();\n    }\n  }\n\n  _onDragDown() {\n    if (!this.isCursorOverPoint) return;\n    this.isDragging = this.isCursorOverPoint;\n    this._map.getCanvas().style.cursor = 'grab';\n\n    this._map.on('mousemove', this.onDragMove);\n\n    this._map.on('mouseup', this.onDragUp);\n\n    this._map.on('touchmove', this.onDragMove);\n\n    this._map.on('touchend', this.onDragUp);\n  }\n\n  _onDragMove(e) {\n    if (!this.isDragging) return;\n    const coords = [e.lngLat.lng, e.lngLat.lat];\n\n    switch (this.isDragging.layer.id) {\n      case 'directions-origin-point':\n        this.actions.createOrigin(coords);\n        break;\n\n      case 'directions-destination-point':\n        this.actions.createDestination(coords);\n        break;\n\n      case 'directions-hover-point':\n        this.actions.hoverMarker(coords);\n        break;\n    }\n  }\n\n  _onDragUp() {\n    if (!this.isDragging) return;\n\n    const _store$getState6 = store.getState(),\n          hoverMarker = _store$getState6.hoverMarker,\n          origin = _store$getState6.origin,\n          destination = _store$getState6.destination;\n\n    switch (this.isDragging.layer.id) {\n      case 'directions-origin-point':\n        this.actions.setOriginFromCoordinates(origin.geometry.coordinates);\n        break;\n\n      case 'directions-destination-point':\n        this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);\n        break;\n\n      case 'directions-hover-point':\n        // Add waypoint if a sufficent amount of dragging has occurred.\n        if (hoverMarker.geometry && !utils.coordinateMatch(this.isDragging, hoverMarker)) {\n          this.actions.addWaypoint(0, hoverMarker);\n        }\n\n        break;\n    }\n\n    this.isDragging = false;\n    this._map.getCanvas().style.cursor = '';\n\n    this._map.off('touchmove', this.onDragMove);\n\n    this._map.off('touchend', this.onDragUp);\n\n    this._map.off('mousemove', this.onDragMove);\n\n    this._map.off('mouseup', this.onDragUp);\n  } // API Methods\n  // ============================\n\n  /**\n   * Turn on or off interactivity\n   * @param {Boolean} state sets interactivity based on a state of `true` or `false`.\n   * @returns {MapboxDirections} this\n   */\n\n\n  interactive(state) {\n    if (state) {\n      this._map.on('touchstart', this.move);\n\n      this._map.on('touchstart', this.onDragDown);\n\n      this._map.on('mousedown', this.onDragDown);\n\n      this._map.on('mousemove', this.move);\n\n      this._map.on('click', this.onClick);\n    } else {\n      this._map.off('touchstart', this.move);\n\n      this._map.off('touchstart', this.onDragDown);\n\n      this._map.off('mousedown', this.onDragDown);\n\n      this._map.off('mousemove', this.move);\n\n      this._map.off('click', this.onClick);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the origin of the current route.\n   * @returns {Object} origin\n   */\n\n\n  getOrigin() {\n    return store.getState().origin;\n  }\n  /**\n   * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n   * @returns {MapboxDirections} this\n   */\n\n\n  setOrigin(query) {\n    if (typeof query === 'string') {\n      this.actions.queryOrigin(query);\n    } else {\n      this.actions.setOriginFromCoordinates(query);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the destination of the current route.\n   * @returns {Object} destination\n   */\n\n\n  getDestination() {\n    return store.getState().destination;\n  }\n  /**\n   * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n   * @returns {MapboxDirections} this\n   */\n\n\n  setDestination(query) {\n    if (typeof query === 'string') {\n      this.actions.queryDestination(query);\n    } else {\n      this.actions.setDestinationFromCoordinates(query);\n    }\n\n    return this;\n  }\n  /**\n   * Swap the origin and destination.\n   * @returns {MapboxDirections} this\n   */\n\n\n  reverse() {\n    this.actions.reverse();\n    return this;\n  }\n  /**\n   * Add a waypoint to the route. _Note:_ calling this method requires the\n   * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.\n   * @param {Number} index position waypoint should be placed in the waypoint array\n   * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n   * @returns {MapboxDirections} this;\n   */\n\n\n  addWaypoint(index, waypoint) {\n    if (!waypoint.type) waypoint = utils.createPoint(waypoint, {\n      id: 'waypoint'\n    });\n    this.actions.addWaypoint(index, waypoint);\n    return this;\n  }\n  /**\n   * Change the waypoint at a given index in the route. _Note:_ calling this\n   * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Number} index indexed position of the waypoint to update\n   * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n   * @returns {MapboxDirections} this;\n   */\n\n\n  setWaypoint(index, waypoint) {\n    if (!waypoint.type) waypoint = utils.createPoint(waypoint, {\n      id: 'waypoint'\n    });\n    this.actions.setWaypoint(index, waypoint);\n    return this;\n  }\n  /**\n   * Remove a waypoint from the route.\n   * @param {Number} index position in the waypoints array.\n   * @returns {MapboxDirections} this;\n   */\n\n\n  removeWaypoint(index) {\n    const _store$getState7 = store.getState(),\n          waypoints = _store$getState7.waypoints;\n\n    this.actions.removeWaypoint(waypoints[index]);\n    return this;\n  }\n  /**\n   * Fetch all current waypoints in a route.\n   * @returns {Array} waypoints\n   */\n\n\n  getWaypoints() {\n    return store.getState().waypoints;\n  }\n  /**\n   * Removes all routes and waypoints from the map.\n   *\n   * @returns {MapboxDirections} this;\n   */\n\n\n  removeRoutes() {\n    this.actions.clearOrigin();\n    this.actions.clearDestination();\n    return this;\n  }\n  /**\n   * Subscribe to events that happen within the plugin.\n   * @param {String} type name of event. Available events and the data passed into their respective event objects are:\n   *\n   * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`\n   * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`\n   * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`\n   * - __origin__ `{ feature } Fired when origin is set`\n   * - __destination__ `{ feature } Fired when destination is set`\n   * - __route__ `{ route } Fired when a route is updated`\n   * - __error__ `{ error } Error as string\n   * @param {Function} fn function that's called when the event is emitted.\n   * @returns {MapboxDirections} this;\n   */\n\n\n  on(type, fn) {\n    this.actions.eventSubscribe(type, fn);\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/altafquadri/Development/code/Mod5Project/Frontend/lead-us-react/node_modules/@mapbox/mapbox-gl-directions/src/directions.js"],"names":["createStore","applyMiddleware","bindActionCreators","thunk","decode","utils","rootReducer","storeWithMiddleware","store","actions","directionsStyle","Inputs","Instructions","MapboxDirections","constructor","options","dispatch","setOptions","onDragDown","_onDragDown","bind","onDragMove","_onDragMove","onDragUp","_onDragUp","move","_move","onClick","_clickHandler","onAdd","map","_map","getState","controls","el","container","document","createElement","className","inputEl","directionsEl","hoverMarker","setRouteIndex","inputs","appendChild","instructions","subscribedActions","loaded","mapState","on","onRemove","parentNode","removeChild","removeRoutes","off","storeUnsubscribe","forEach","layer","getLayer","id","removeLayer","getSource","removeSource","profile","alternatives","congestion","styles","interactive","compile","eventEmit","geojson","type","data","features","addSource","length","style","addLayer","subscribe","origin","destination","directions","routeIndex","filter","d","geometry","feature","index","decoded","c","reverse","i","previous","legs","annotation","properties","coordinates","push","segment","route","concat","steps","maneuver","location","setData","timer","delay","event","singleClickHandler","_onSingleClick","setTimeout","clearTimeout","zoomIn","e","coords","lngLat","lng","lat","setOriginFromCoordinates","queryRenderedFeatures","point","layers","f","removeWaypoint","setDestinationFromCoordinates","flyTo","center","getCanvas","cursor","isCursorOverPoint","dragPan","disable","enable","isDragging","createOrigin","createDestination","coordinateMatch","addWaypoint","state","getOrigin","setOrigin","query","queryOrigin","getDestination","setDestination","queryDestination","waypoint","createPoint","setWaypoint","waypoints","getWaypoints","clearOrigin","clearDestination","fn","eventSubscribe"],"mappings":"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","sourcesContent":["import { createStore, applyMiddleware, bindActionCreators } from 'redux';\nimport thunk from 'redux-thunk';\nimport { decode } from '@mapbox/polyline';\nimport utils from './utils';\nimport rootReducer from './reducers';\n\nconst storeWithMiddleware = applyMiddleware(thunk)(createStore);\nconst store = storeWithMiddleware(rootReducer);\n\n// State object management via redux\nimport * as actions from './actions';\nimport directionsStyle from './directions_style';\n\n// Controls\nimport Inputs from './controls/inputs';\nimport Instructions from './controls/instructions';\n\n/**\n * The Directions control\n * @class MapboxDirections\n *\n * @param {Object} options\n * @param {Array} [options.styles] Override default layer properties of the [directions source](https://github.com/mapbox/mapbox-gl-directions/blob/master/src/directions_style.js). Documentation for each property are specified in the [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/).\n * @param {String} [options.accessToken=null] Required unless `mapboxgl.accessToken` is set globally\n * @param {String} [options.api=\"https://api.mapbox.com/directions/v5/\"] Override default routing endpoint url\n * @param {Boolean} [options.interactive=true] Enable/Disable mouse or touch interactivity from the plugin\n * @param {String} [options.profile=\"mapbox/driving-traffic\"] Routing profile to use. Options: `mapbox/driving-traffic`, `mapbox/driving`, `mapbox/walking`, `mapbox/cycling`\n * @param {Boolean} [options.alternatives=false] Whether to enable alternatives.\n * @param {Boolean} [options.congestion=false] Whether to enable congestion along the route line.\n * @param {String} [options.unit=\"imperial\"] Measurement system to be used in navigation instructions. Options: `imperial`, `metric`\n * @param {Function} [options.compile=null] Provide a custom function for generating instruction, compatible with osrm-text-instructions.\n * @param {Object} [options.geocoder] Accepts an object containing the query parameters as [documented here](https://www.mapbox.com/api-documentation/#search-for-places).\n * @param {Object} [options.controls]\n * @param {Boolean} [options.controls.inputs=true] Hide or display the inputs control.\n * @param {Boolean} [options.controls.instructions=true] Hide or display the instructions control.\n * @param {Boolean} [options.controls.profileSwitcher=true] Hide or display the default profile switch with options for traffic, driving, walking and cycling.\n * @param {Number} [options.zoom=16] If no bbox exists from the geocoder result, the zoom you set here will be used in the flyTo.\n * @param {String} [options.language=\"en\"] The language of returned turn-by-turn text instructions. See supported languages : https://docs.mapbox.com/api/navigation/#instructions-languages\n * @param {String} [options.placeholderOrigin=\"Choose a starting place\"] If set, this text will appear as the placeholder attribute for the origin input element.\n * @param {String} [options.placeholderDestination=\"Choose destination\"] If set, this text will appear as the placeholder attribute for the destination input element.\n * @param {Boolean} [options.flyTo=true] If false, animating the map to a selected result is disabled.\n * @example\n * var MapboxDirections = require('../src/index');\n * var directions = new MapboxDirections({\n *   accessToken: 'YOUR-MAPBOX-ACCESS-TOKEN',\n *   unit: 'metric',\n *   profile: 'mapbox/cycling'\n * });\n * // add to your mapboxgl map\n * map.addControl(directions);\n *\n * @return {MapboxDirections} `this`\n */\nexport default class MapboxDirections {\n\n  constructor(options) {\n    this.actions = bindActionCreators(actions, store.dispatch);\n    this.actions.setOptions(options || {});\n    this.options = options || {};\n\n    this.onDragDown = this._onDragDown.bind(this);\n    this.onDragMove = this._onDragMove.bind(this);\n    this.onDragUp = this._onDragUp.bind(this);\n    this.move = this._move.bind(this);\n    this.onClick = this._clickHandler().bind(this);\n  }\n\n  onAdd(map) {\n    this._map = map;\n\n    const { controls } = store.getState();\n\n    var el = this.container = document.createElement('div');\n    el.className = 'mapboxgl-ctrl-directions mapboxgl-ctrl';\n\n    // Add controls to the page\n    const inputEl = document.createElement('div');\n    inputEl.className = 'directions-control directions-control-inputs';\n    new Inputs(inputEl, store, this.actions, this._map);\n\n    const directionsEl = document.createElement('div');\n    directionsEl.className = 'directions-control directions-control-instructions';\n\n    new Instructions(directionsEl, store, {\n      hoverMarker: this.actions.hoverMarker,\n      setRouteIndex: this.actions.setRouteIndex\n    }, this._map);\n\n    if (controls.inputs) el.appendChild(inputEl);\n    if (controls.instructions) el.appendChild(directionsEl);\n\n    this.subscribedActions();\n    if (this._map.loaded()) this.mapState()\n    else this._map.on('load', () => this.mapState());\n\n    return el;\n  }\n\n  /**\n   * Removes the control from the map it has been added to. This is called by `map.removeControl`,\n   * which is the recommended method to remove controls.\n   *\n   * @returns {Control} `this`\n   */\n  onRemove(map) {\n    this.container.parentNode.removeChild(this.container);\n    this.removeRoutes();\n    map.off('mousedown', this.onDragDown);\n    map.off('mousemove', this.move);\n    map.off('touchstart', this.onDragDown);\n    map.off('touchstart', this.move);\n    map.off('click', this.onClick);\n    if (this.storeUnsubscribe) {\n      this.storeUnsubscribe();\n      delete this.storeUnsubscribe;\n    }\n    directionsStyle.forEach((layer) => {\n      if (map.getLayer(layer.id)) map.removeLayer(layer.id);\n    });\n\n    if (map.getSource('directions')) map.removeSource('directions');\n\n    this._map = null;\n    return this;\n  }\n\n  mapState() {\n    const { profile, alternatives, congestion, styles, interactive, compile } = store.getState();\n\n    // Emit any default or option set config\n    this.actions.eventEmit('profile', { profile });\n\n    const geojson = {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: []\n      }\n    };\n\n    // Add and set data theme layer/style\n    this._map.addSource('directions', geojson);\n\n    // Add direction specific styles to the map\n    if (styles && styles.length) styles.forEach((style) => this._map.addLayer(style));\n    directionsStyle.forEach((style) => {\n      // only add the default style layer if a custom layer wasn't provided\n      if (!this._map.getLayer(style.id)) this._map.addLayer(style);\n    });\n\n\n    if (interactive) {\n      this._map.on('mousedown', this.onDragDown);\n      this._map.on('mousemove', this.move);\n      this._map.on('click', this.onClick);\n\n      this._map.on('touchstart', this.move);\n      this._map.on('touchstart', this.onDragDown);\n    }\n  }\n\n  subscribedActions() {\n    this.storeUnsubscribe = store.subscribe(() => {\n      const {\n        origin,\n        destination,\n        hoverMarker,\n        directions,\n        routeIndex\n      } = store.getState();\n\n      const geojson = {\n        type: 'FeatureCollection',\n        features: [\n          origin,\n          destination,\n          hoverMarker\n        ].filter((d) => {\n          return d.geometry;\n        })\n      };\n\n      if (directions.length) {\n        directions.forEach((feature, index) => {\n\n          const features = [];\n\n          const decoded = decode(feature.geometry, 5).map(function(c) {\n            return c.reverse();\n          });\n\n          decoded.forEach(function(c, i) {\n            var previous = features[features.length - 1];\n            var congestion = feature.legs[0].annotation && feature.legs[0].annotation.congestion && feature.legs[0].annotation.congestion[i - 1];\n\n            if (previous && (!congestion || previous.properties.congestion === congestion)) {\n              previous.geometry.coordinates.push(c);\n            } else {\n              var segment = {\n                geometry: {\n                  type: 'LineString',\n                  coordinates: []\n                },\n                properties: {\n                  'route-index': index,\n                  route: (index === routeIndex) ? 'selected' : 'alternate',\n                }\n              };\n\n              // New segment starts with previous segment's last coordinate.\n              if (previous) segment.geometry.coordinates.push(previous.geometry.coordinates[previous.geometry.coordinates.length - 1]);\n\n              segment.geometry.coordinates.push(c);\n\n              if (congestion) {\n                segment.properties.congestion = feature.legs[0].annotation.congestion[i - 1];\n              }\n\n              features.push(segment);\n            }\n          });\n\n          geojson.features = geojson.features.concat(features);\n\n          if (index === routeIndex) {\n            // Collect any possible waypoints from steps\n            feature.legs[0].steps.forEach((d) => {\n              if (d.maneuver.type === 'waypoint') {\n                geojson.features.push({\n                  type: 'Feature',\n                  geometry: d.maneuver.location,\n                  properties: {\n                    id: 'waypoint'\n                  }\n                });\n              }\n            });\n          }\n\n        });\n      }\n\n      if (this._map.style && this._map.getSource('directions')) {\n        this._map.getSource('directions').setData(geojson);\n      }\n    });\n  }\n\n  _clickHandler() {\n    var timer = null;\n    var delay = 250;\n    return function(event) {\n      if (!timer) {\n        var singleClickHandler = this._onSingleClick.bind(this);\n\n        timer = setTimeout(function() {\n          singleClickHandler(event);\n          timer = null;\n        }, delay);\n\n      } else {\n        clearTimeout(timer);\n        timer = null;\n        this._map.zoomIn();\n      }\n    };\n  }\n\n  _onSingleClick(e) {\n    const { origin } = store.getState();\n    const coords = [e.lngLat.lng, e.lngLat.lat];\n\n    if (!origin.geometry) {\n      this.actions.setOriginFromCoordinates(coords);\n    } else {\n\n      const features = this._map.queryRenderedFeatures(e.point, {\n        layers: [\n          'directions-origin-point',\n          'directions-destination-point',\n          'directions-waypoint-point',\n          'directions-route-line-alt'\n        ]\n      });\n\n      if (features.length) {\n\n        // Remove any waypoints\n        features.forEach((f) => {\n          if (f.layer.id === 'directions-waypoint-point') {\n            this.actions.removeWaypoint(f);\n          }\n        });\n\n        if (features[0].properties.route === 'alternate') {\n          const index = features[0].properties['route-index'];\n          this.actions.setRouteIndex(index);\n        }\n      } else {\n        this.actions.setDestinationFromCoordinates(coords);\n        this._map.flyTo({ center: coords });\n      }\n    }\n  }\n\n  _move(e) {\n    const { hoverMarker } = store.getState();\n\n    const features = this._map.queryRenderedFeatures(e.point, {\n      layers: [\n        'directions-route-line-alt',\n        'directions-route-line',\n        'directions-origin-point',\n        'directions-destination-point',\n        'directions-hover-point'\n      ]\n    });\n\n    this._map.getCanvas().style.cursor = features.length ? 'pointer' : '';\n\n    if (features.length) {\n      this.isCursorOverPoint = features[0];\n      this._map.dragPan.disable();\n\n      // Add a possible waypoint marker when hovering over the active route line\n      features.forEach((feature) => {\n        if (feature.layer.id === 'directions-route-line') {\n          this.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);\n        } else if (hoverMarker.geometry) {\n          this.actions.hoverMarker(null);\n        }\n      });\n\n    } else if (this.isCursorOverPoint) {\n      this.isCursorOverPoint = false;\n      this._map.dragPan.enable();\n    }\n  }\n\n  _onDragDown() {\n    if (!this.isCursorOverPoint) return;\n    this.isDragging = this.isCursorOverPoint;\n    this._map.getCanvas().style.cursor = 'grab';\n\n    this._map.on('mousemove', this.onDragMove);\n    this._map.on('mouseup', this.onDragUp);\n\n    this._map.on('touchmove', this.onDragMove);\n    this._map.on('touchend', this.onDragUp);\n  }\n\n  _onDragMove(e) {\n    if (!this.isDragging) return;\n\n    const coords = [e.lngLat.lng, e.lngLat.lat];\n    switch (this.isDragging.layer.id) {\n      case 'directions-origin-point':\n        this.actions.createOrigin(coords);\n      break;\n      case 'directions-destination-point':\n        this.actions.createDestination(coords);\n      break;\n      case 'directions-hover-point':\n        this.actions.hoverMarker(coords);\n      break;\n    }\n  }\n\n  _onDragUp() {\n    if (!this.isDragging) return;\n\n    const { hoverMarker, origin, destination } = store.getState();\n\n    switch (this.isDragging.layer.id) {\n      case 'directions-origin-point':\n        this.actions.setOriginFromCoordinates(origin.geometry.coordinates);\n      break;\n      case 'directions-destination-point':\n        this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);\n      break;\n      case 'directions-hover-point':\n        // Add waypoint if a sufficent amount of dragging has occurred.\n        if (hoverMarker.geometry && !utils.coordinateMatch(this.isDragging, hoverMarker)) {\n          this.actions.addWaypoint(0, hoverMarker);\n        }\n      break;\n    }\n\n    this.isDragging = false;\n    this._map.getCanvas().style.cursor = '';\n\n    this._map.off('touchmove', this.onDragMove);\n    this._map.off('touchend', this.onDragUp);\n\n    this._map.off('mousemove', this.onDragMove);\n    this._map.off('mouseup', this.onDragUp);\n  }\n\n  // API Methods\n  // ============================\n\n  /**\n   * Turn on or off interactivity\n   * @param {Boolean} state sets interactivity based on a state of `true` or `false`.\n   * @returns {MapboxDirections} this\n   */\n  interactive(state) {\n    if (state) {\n      this._map.on('touchstart', this.move);\n      this._map.on('touchstart', this.onDragDown);\n\n      this._map.on('mousedown', this.onDragDown);\n      this._map.on('mousemove', this.move);\n      this._map.on('click', this.onClick);\n    } else {\n      this._map.off('touchstart', this.move);\n      this._map.off('touchstart', this.onDragDown);\n\n      this._map.off('mousedown', this.onDragDown);\n      this._map.off('mousemove', this.move);\n      this._map.off('click', this.onClick);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the origin of the current route.\n   * @returns {Object} origin\n   */\n  getOrigin() {\n    return store.getState().origin;\n  }\n\n  /**\n   * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n   * @returns {MapboxDirections} this\n   */\n  setOrigin(query) {\n    if (typeof query === 'string') {\n      this.actions.queryOrigin(query);\n    } else {\n      this.actions.setOriginFromCoordinates(query);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the destination of the current route.\n   * @returns {Object} destination\n   */\n  getDestination() {\n    return store.getState().destination;\n  }\n\n  /**\n   * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n   * @returns {MapboxDirections} this\n   */\n  setDestination(query) {\n    if (typeof query === 'string') {\n      this.actions.queryDestination(query);\n    } else {\n      this.actions.setDestinationFromCoordinates(query);\n    }\n\n    return this;\n  }\n\n  /**\n   * Swap the origin and destination.\n   * @returns {MapboxDirections} this\n   */\n  reverse() {\n    this.actions.reverse();\n    return this;\n  }\n\n  /**\n   * Add a waypoint to the route. _Note:_ calling this method requires the\n   * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.\n   * @param {Number} index position waypoint should be placed in the waypoint array\n   * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n   * @returns {MapboxDirections} this;\n   */\n  addWaypoint(index, waypoint) {\n    if (!waypoint.type) waypoint = utils.createPoint(waypoint, { id: 'waypoint' });\n    this.actions.addWaypoint(index, waypoint);\n    return this;\n  }\n\n  /**\n   * Change the waypoint at a given index in the route. _Note:_ calling this\n   * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n   * to have run.\n   * @param {Number} index indexed position of the waypoint to update\n   * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n   * @returns {MapboxDirections} this;\n   */\n  setWaypoint(index, waypoint) {\n    if (!waypoint.type) waypoint = utils.createPoint(waypoint, { id: 'waypoint' });\n    this.actions.setWaypoint(index, waypoint);\n    return this;\n  }\n\n  /**\n   * Remove a waypoint from the route.\n   * @param {Number} index position in the waypoints array.\n   * @returns {MapboxDirections} this;\n   */\n  removeWaypoint(index) {\n    const { waypoints } = store.getState();\n    this.actions.removeWaypoint(waypoints[index]);\n    return this;\n  }\n\n  /**\n   * Fetch all current waypoints in a route.\n   * @returns {Array} waypoints\n   */\n  getWaypoints() {\n    return store.getState().waypoints;\n  }\n\n  /**\n   * Removes all routes and waypoints from the map.\n   *\n   * @returns {MapboxDirections} this;\n   */\n  removeRoutes() {\n    this.actions.clearOrigin();\n    this.actions.clearDestination();\n    return this;\n  }\n\n  /**\n   * Subscribe to events that happen within the plugin.\n   * @param {String} type name of event. Available events and the data passed into their respective event objects are:\n   *\n   * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`\n   * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`\n   * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`\n   * - __origin__ `{ feature } Fired when origin is set`\n   * - __destination__ `{ feature } Fired when destination is set`\n   * - __route__ `{ route } Fired when a route is updated`\n   * - __error__ `{ error } Error as string\n   * @param {Function} fn function that's called when the event is emitted.\n   * @returns {MapboxDirections} this;\n   */\n  on(type, fn) {\n    this.actions.eventSubscribe(type, fn);\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}