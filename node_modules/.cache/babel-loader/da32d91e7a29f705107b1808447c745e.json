{"ast":null,"code":"import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return dispatch => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n    dispatch({\n      type: types.ORIGIN,\n      origin\n    });\n    dispatch(eventEmit('origin', {\n      feature: origin\n    }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return dispatch => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n    dispatch({\n      type: types.DESTINATION,\n      destination\n    });\n    dispatch(eventEmit('destination', {\n      feature: destination\n    }));\n  };\n}\n\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', {\n      route: directions\n    }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const _getState = getState(),\n          api = _getState.api,\n          accessToken = _getState.accessToken,\n          routeIndex = _getState.routeIndex,\n          profile = _getState.profile,\n          alternatives = _getState.alternatives,\n          congestion = _getState.congestion,\n          destination = _getState.destination,\n          language = _getState.language; // if there is no destination set, do not make request because it will fail\n\n\n    if (!(destination && destination.geometry)) return;\n    const query = buildDirectionsQuery(getState); // Request params\n\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language=' + language);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', `${api}${profile}/${query}.json?${options.join('&')}`, true);\n\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes)); // Revise origin / destination points\n\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\n\n\nfunction buildDirectionsQuery(state) {\n  const _state = state(),\n        origin = _state.origin,\n        destination = _state.destination,\n        waypoints = _state.waypoints;\n\n  let query = [];\n  query.push(origin.geometry.coordinates.join(','));\n  query.push(';'); // Add any waypoints.\n\n  if (waypoints.length) {\n    waypoints.forEach(waypoint => {\n      query.push(waypoint.geometry.coordinates.join(','));\n      query.push(';');\n    });\n  }\n\n  query.push(destination.geometry.coordinates.join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  const properties = {\n    id: 'waypoint'\n  };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties\n  });\n}\n\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', {\n      error: error\n    }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'origin'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'destination'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\nexport function hoverMarker(coordinates) {\n  return dispatch => {\n    const feature = coordinates ? utils.createPoint(coordinates, {\n      id: 'hover'\n    }) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const _getState2 = getState(),\n          destination = _getState2.destination;\n\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const _getState3 = getState(),\n          origin = _getState3.origin;\n\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const _getState4 = getState(),\n          origin = _getState4.origin,\n          destination = _getState4.destination;\n\n    dispatch({\n      type: types.DIRECTIONS_PROFILE,\n      profile\n    });\n    dispatch(eventEmit('profile', {\n      profile\n    }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n  };\n}\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\n\nexport function setOriginFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\n\nexport function setDestinationFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let _getState5 = getState(),\n        destination = _getState5.destination,\n        waypoints = _getState5.waypoints;\n\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let _getState6 = getState(),\n        destination = _getState6.destination,\n        waypoints = _getState6.waypoints;\n\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let _getState7 = getState(),\n        destination = _getState7.destination,\n        waypoints = _getState7.waypoints;\n\n    waypoints = waypoints.filter(way => {\n      return !utils.coordinateMatch(way, waypoint);\n    });\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const _getState8 = getState(),\n          events = _getState8.events;\n\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const _getState9 = getState(),\n          events = _getState9.events;\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n\n    const listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/altafquadri/Development/code/Mod5Project/Frontend/lead-us-react/node_modules/@mapbox/mapbox-gl-directions/src/actions/index.js"],"names":["types","utils","request","XMLHttpRequest","originPoint","coordinates","dispatch","origin","createPoint","id","type","ORIGIN","eventEmit","feature","destinationPoint","destination","DESTINATION","setDirections","directions","DIRECTIONS","route","updateWaypoints","waypoints","WAYPOINTS","setHoverMarker","HOVER_MARKER","hoverMarker","fetchDirections","getState","api","accessToken","routeIndex","profile","alternatives","congestion","language","geometry","query","buildDirectionsQuery","options","push","abort","open","join","onload","status","data","JSON","parse","responseText","error","setError","routes","setRouteIndex","location","length","message","onerror","send","state","forEach","waypoint","encodeURIComponent","normalizeWaypoint","properties","Object","assign","queryOrigin","ORIGIN_QUERY","queryDestination","DESTINATION_QUERY","queryOriginCoordinates","coords","ORIGIN_FROM_COORDINATES","queryDestinationCoordinates","DESTINATION_FROM_COORDINATES","clearOrigin","ORIGIN_CLEAR","clearDestination","DESTINATION_CLEAR","setOptions","SET_OPTIONS","ROUTE_INDEX","createOrigin","createDestination","setProfile","DIRECTIONS_PROFILE","reverse","setOriginFromCoordinates","validCoords","wrap","isNaN","Error","setDestinationFromCoordinates","addWaypoint","index","splice","setWaypoint","removeWaypoint","filter","way","coordinateMatch","eventSubscribe","fn","events","EVENTS","listeners","slice","i","call"],"mappings":"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","sourcesContent":["import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return (dispatch) => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n\n    dispatch({ type: types.ORIGIN, origin });\n    dispatch(eventEmit('origin', { feature: origin }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return (dispatch) => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n\n    dispatch({ type: types.DESTINATION, destination });\n    dispatch(eventEmit('destination', { feature: destination }));\n  };\n}\n\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', { route: directions }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const { api, accessToken, routeIndex, profile, alternatives, congestion, destination, language } = getState();\n    // if there is no destination set, do not make request because it will fail\n    if (!(destination && destination.geometry)) return;\n\n    const query = buildDirectionsQuery(getState);\n\n    // Request params\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language='+language);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', `${api}${profile}/${query}.json?${options.join('&')}`, true);\n\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes));\n\n        // Revise origin / destination points\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\nfunction buildDirectionsQuery(state) {\n  const { origin, destination, waypoints } = state();\n\n  let query = [];\n  query.push((origin.geometry.coordinates).join(','));\n  query.push(';');\n\n  // Add any waypoints.\n  if (waypoints.length) {\n    waypoints.forEach((waypoint) => {\n      query.push((waypoint.geometry.coordinates).join(','));\n      query.push(';');\n    });\n  }\n\n  query.push((destination.geometry.coordinates).join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  const properties = { id: 'waypoint' };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ?\n      Object.assign(waypoint.properties, properties) :\n      properties\n  });\n}\n\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', { error: error }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\n\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\n\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'origin' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'destination' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\n\nexport function hoverMarker(coordinates) {\n  return (dispatch) => {\n    const feature = (coordinates) ? utils.createPoint(coordinates, { id: 'hover'}) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\n\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\n\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const { destination } = getState();\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const { origin } = getState();\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const { origin, destination } = getState();\n    dispatch({ type: types.DIRECTIONS_PROFILE, profile });\n    dispatch(eventEmit('profile', { profile }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n  };\n}\n\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\nexport function setOriginFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\nexport function setDestinationFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\n\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n      waypoints = waypoints.filter((way) => {\n        return !utils.coordinateMatch(way, waypoint);\n      });\n\n      dispatch(updateWaypoints(waypoints));\n      if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\n\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n\n    const listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}